
## 1.概念 
        选择排序(Selection sort)是一种简单直观的排序算法。它的工作原理是，首先在未排序序列中找到最小（大）元素，
     存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此
     类推，直到所有元素均排序完毕。
     
     选择排序是不稳定的排序方法（比如序列[5， 5， 3]第一次就将第一个[5]与[3]交换，导致第一个5挪动到第二个5后面）。  
      
        选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元
     素，它们当中至少有一个将被移到其最终位置上，因此对 n个元素的表进行排序总共进行至多 n-1 次交换。在所有的完全依
     靠交换去移动元素的排序方法中，选择排序属于非常好的一种。  
       
## 2.思路
       1.从未排序序列中，找到关键字最小的元素  
       2.如果最小元素不是未排序序列的第一个元素，将其和未排序序列第一个元素互换  
       3.重复1、2步，直到排序结束。  
    
![select](./images/select.gif) 
    
## 3.代码实现要点

    两个for循环，外层循环控制排序的趟数，内层循环找到当前趟数的最小（或最大）值，随后与当前趟未排序的数组序列第一个元素互换。
    
## 4.关键代码
```
       public static void selectionSort(int[] arr) {
               for (int i = 0; i < arr.length - 1; i++) {//需要比较的次数，数组长度减一
                   //先假设每次循环时，最小数的索引为i
                   int minIndex = i;
                   //每一个元素都和剩下的未排序的元素比较
                   for (int j = i + 1; j < arr.length; j++) {
                       if (arr[j] < arr[minIndex]) {//寻找最小数
                           minIndex = j;//将最小数的索引保存
                       }
                   }
                   //经过一轮循环，就可以找出第一个最小值的索引，然后把最小值放到i的位置
                   swap(arr, i, minIndex);
               }
           }
       
           private static void swap(int[] arr, int i, int j) {
               int temp = arr[i];
               arr[i] = arr[j];
               arr[j] = temp;
           }
```

## 5.复杂度分析  

    平均时间复杂度：O(n²)	
    最好情况：O(n²)  
	最坏情况：O(n²)  
	空间复杂度：O(1)

## 6.实现代码
   [查看示例](./SelectionSort.java)

## 7.总结  
    选择排序的简单和直观名副其实，这也造就了它”出了名的慢性子”，无论是哪种情况，哪怕原数组已排序完成，
    它也将花费将近n²/2次遍历来确认一遍。即便是这样，它的排序结果也还是不稳定的。 唯一值得高兴的是，它并
    不耗费额外的内存空间。