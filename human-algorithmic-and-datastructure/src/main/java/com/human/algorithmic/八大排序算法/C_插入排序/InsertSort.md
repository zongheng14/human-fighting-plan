
## 1.概念 
        插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适
     用于少量数据的排序，时间复杂度为O(n^2)。是稳定的排序方法。  
     
## 2.思路  
        将一个元素插入到已有序的数组中，在初始时未知是否存在有序的数据，因此将元素第一个元素看成是有序的。与有序的
     数组进行比较，比它大则直接放入，比它小则移动数组元素的位置，找到个合适的位置插入。当只有一个数时，则不需要插入
     了，因此需要n-1趟排序  
       
     一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：
         1.从第一个元素开始，该元素可以认为已经被排序  
         2.取出下一个元素，在已经排序的元素序列中从后向前扫描  
         3.如果该元素（已排序）大于新元素，将该元素移到下一位置  
         4.重复步骤3，直到找到已排序的元素小于或者等于新元素的位置  
         5.将新元素插入到该位置后  
         6.重复步骤2~5  
         
![insert](./images/insert.gif) 
    
## 3.代码实现要点  
    一个for循环内嵌一个while循环实现，外层for循环控制需要排序的趟数，while循环找到合适的插入位置(并且插入的位置不能小于0)
    
## 4.关键代码
```
   /**
    * 通过交换进行插入排序，借鉴冒泡排序
    */
   public static void sort(int[] a) {
       for (int i = 0; i < a.length - 1; i++) {
           for (int j = i + 1; j > 0; j--) {
               if (a[j] < a[j - 1]) {
                   int temp = a[j];
                   a[j] = a[j - 1];
                   a[j - 1] = temp;
               }
           }
       }
   }
   
   /**
    * 通过将较大的元素都向右移动而不总是交换两个元素
    */
   public static void sort2(int[] a) {
       for (int i = 1; i < a.length; i++) {
           int num = a[i];
           int j;
           for (j = i; j > 0 && num < a[j - 1]; j--) {
               a[j] = a[j - 1];
           }
           a[j] = num;
       }
   }
```

## 5.复杂度分析   
    平均时间复杂度：O(n²)  
    最好情况：O(n²)    
    最坏情况：O(n²)    
    空间复杂度：O(1)  
    			

## 6.实现代码
   [查看示例](./InsertSort.java)  
   
## 7.总结  
    插入排序所需的时间取决于输入元素的初始顺序。例如，对一个很大且其中的元素已经有序(或接近有序)的数组进行排序将会比
    随机顺序的数组或是逆序数组进行排序要快得多。